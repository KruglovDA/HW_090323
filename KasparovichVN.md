![](GitLogo.jpg) 


# Основные команды Git



1. ## Имя пользователя и адресс электронной почты ## 
   **git config --global user.name**  - назначение или изменение имени пользователя. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. Если хотите скрыть своё реальное имя, можно использовать в качестве имени пользователя Git произвольный набор символов.  
   *git config --global user.name "Tara Routray"*
   
   **git config --global user.email ** - задание или изменение адреса электронной почты, привязанный к вашим коммитам Git. Новый адрес электронной почты будет автоматически отображаться во всех дальнейших коммитах, поданных на GitHub через командную строку.  
   *git config --global user.email "dev@tararoutray.com"*  

   Чтобы указать уровень конфигурации, на котором производится работа, к команде **git config** можно добавить аргументы. Доступны следующие уровни конфигурации:  
      * **--local** - по умолчанию, если не были переданы опции конфигурации, команда **git config** будет вести запись на локальном уровне. Конфигурация локального уровня применяется к репозиторию, в котором вызывается команда **git config**. Значения локальной конфигурации хранятся в файле, который находится в каталоге _**.git репозитория: .git/config**_  
      * **--global** - конфигурация глобального уровня зависит от пользователя, то есть применяется к пользователю операционной системы. Значения глобальной конфигурации хранятся в файле, который находится в домашнем каталоге пользователя. Это _**~ /.gitconfig**_ в Unix-системах и  _**C:\<имя_пользователя>\.gitconfig**_ в системах Windows.

1. ## Кэширование учётных данных ##
   Кэшировать учётные данные можно с помощью параметра **config** с флагом **--global**. Так вы избавитесь от необходимости вручную вводить имя пользователя и пароль при создании нового коммита.  
   *git config --global credential.helper cache*
1. ## Инициализация репозитория 
   **init** Создание пустого репозитория Git или вновь инициализирование существующего. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.  При указании аргумента  команда выполняется в соответствующем каталоге. Если каталог не существует, он будет создан.
 **git init** создать новый проект в текущей директории  
 **git init folder-name** создать новый проект в указанной директории
1. ## 4. Создание файла #
   **touch** создание файла.  
 *touch README.md*
5. ## Удаление файла из **stage** ##
   Если нам необходимо убрать из **stage,** какой-то файл, то для этого можно воспользоваться командой **git –rm cashed <filename>**  
 *git rm --cached main.c*  
 rm 'main.c'
6. ## Удаление файлов из git репозитория
   Удалить файл из репозитория можно двумя способами: первый – удалить его из рабочей директории и уведомить об этом git; второй – воспользоваться средствами git.  
   **Первый способ.**  Удалим файл *main.c* из рабочей директории *rm main.c*, затем уведомим об этом систему git. *git rm main.c  
 rm 'main.c'*  
   >Вместо команды **git rm** можно использовать **git add**, но само слово *add* в данном случае будет звучать несколько неоднозначно, поэтому лучше использовать *rm*. На данном этапе еще можно вернуть все назад с помощью команды **git checkout — <filename>**, в результате, в рабочую директорию будет скопирован файл из репозитория.  
 
    **Второй способ** – это сразу использовать команду **git rm** без предварительного удаления файла из директории.  
    *git rm main.c  
    rm 'main.c'*  
   >Файла *main.c* больше нет в репозитории. Его также нет и в рабочем каталоге  .  

7. ## Клонирование репозитория **git clone**
   * ### клонировать удаленный репозиторий в одноименную директорию  
   *git clone https://github.com/cyberspacedk/Git-commands.git*    
   * ### клонировать удаленный репозиторий в директорию «FolderName»  
   *git clone https://github.com/cyberspacedk/Git-commands.git FolderName* 
   * ### клонировать репозиторий в текущую директорию  
   *git clone https://github.com:nicothin/web-design.git .*

1. ## Добавление отдельных файлов или всех файлов в область подготовленных файлов **git add**  
   Добавить отдельный файл в область подготовленных файлов можно параметром **add** с указанием имени файла *git add somefile.js*. Кроме того, можно добавить все файлы и папки в эту область, предоставив Wildcard . вместо имени файла:  
   * **git add .** - добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий  
   * **git add -i** - запустить интерактивную оболочку для добавления в индекс только выбранных файлов  
   * **git add -p** - показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании
1. ## Проверка статуса репозитория **status**
   Просмотреть статус нужного репозитория можно по ключевому слову **status** его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.  
   * **git status** - показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)
1. ## Внесение изменений однострочным сообщением или через редактор
   При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра **commit** с флагом **-m**. Само сообщение вводится непосредственно после флага, в кавычках.  
 *git commit -m "Your short summary about the commit"*  
Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.
git commit  
**git commit --amend** - этот параметр добавляет команде _**commit**_ новый уровень функциональности. При передаче этого параметра будет изменен последний коммит. Вместо создания нового коммита проиндексированные изменения будут добавлены в предыдущий коммит. Кроме того, эта команда откроет настроенный текстовый редактор системы с предложением изменить указанный ранее комментарий к коммиту.
1. ## Просмотр истории коммитов с изменениями
   Просматривать изменения, внесённые в репозиторий, можно с помощью параметра **log**. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг **-p**, вы можете подробно изучить изменения, внесённые в каждый файл.  
   * **git log –p**
   * **git log master** - показать коммиты в указанной ветке  
   * **git log -2** - показать последние 2 коммита в активной ветке  
   * **git log -2 --stat** - показать последние 2 коммита и статистику внесенных ими изменений  
   * **git log -p -22** - показать последние 22 коммита и внесенную ими разницу на уровне строк  
   * **git log --graph -10** - показать последние 10 коммитов с ASCII-представлением ветвления  
   * **git log --since=2.weeks** - показать коммиты за последние 2 недели  
   * **git log --after '2018-06-30'** - показать коммиты, сделанные после указанной даты  
   * **git log index.html** - показать историю изменений файла index.html (только коммиты)  
   * **git log -5 index.html** - показать историю изменений файла index.html, последние 5 коммитов (только коммиты)  
   * **git log -p index.html** - показать историю изменений файла index.html (коммиты и изменения)  
   * **git log -G'myFunction' -p** - показать все коммиты, в которых менялись строки с myFunction (в кавычках регулярное выражение)  
   * **git log -L '/<head>/','/<\/head>/':index.html** - показать изменения от указанного до указанного регулярных выражений в указанном файле  
   * **git log --grep fix** показать коммиты, в описании которых есть буквосочетание fix (регистрозависимо, только коммиты текущей ветки)  
   * **git log --grep fix -i** - показать коммиты, в описании которых есть буквосочетание fix (регистроНЕзависимо, только коммиты текущей ветки)  
   * **git log --grep 'fix(ing|me)' -P** - показать коммиты, в описании которых есть совпадения для регулярного выражения (только коммиты текущей ветки)  
   * **git log --pretty=format:"%h - %an, %ar : %s" -4** - показать последние 4 коммита с форматированием выводимых данных  
   * **git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short** - мой формат вывода, висящий на алиасе оболочки
   * **git log master..branch_99** - показать коммиты из ветки branch_99, которые не влиты в master  
   * **git log branch_99..master** - показать коммиты из ветки master, которые не влиты в branch_99  
   * **git log master...branch_99 --boundary -- graph** - показать коммиты из указанных веток, начиная с их расхождения (коммит расхождения будет показан)  
   * **git show 60d6582** - показать изменения из коммита с указанным хешем  
   * **git show HEAD~** - показать данные о предыдущем коммите в активной ветке  
   * **git show @~** - аналогично предыдущему       
1. ## Просмотр заданного коммита
   Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.  
*git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29*  
Также можно использовать сокращённый хеш.  
*git show 1af17e*
   * **git show HEAD~3** - показать данные о коммите, который был 3 коммита назад  
   * **git show my_branch~2** - показать данные о коммите, который был 2 коммита назад в указанной ветке  
   * **git show @~:index.html** - показать контент указанного файла на момент предыдущего (от HEAD) коммита  
   * **git show :/"подвал"** - показать самый новый коммит, в описании которого есть указанное слово (из любой ветки)
1. ## Просмотр изменений до коммита
   Можно просматривать список изменений, внесённых в репозиторий, используя параметр **diff**. По умолчанию отображаются только изменения, не подготовленные для фиксации.  
   * **git diff** - сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)  
   * **git diff --color-words** - сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)  
   * **git diff index.html** - сравнить файл из рабочей директории и индекс  
   * **git diff HEAD** - сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)  
   * **git diff --staged** - сравнить индекс и коммит с HEAD  
   * **git diff master feature** - посмотреть что сделано в ветке feature по сравнению с веткой master  
   * **git diff --name-only master feature** - посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов  
   * **git diff master...feature** - посмотреть что сделано в ветке feature с момента (коммита) расхождения с master  
   * **git diff --color-words** - специальный режим подсветки изменений с повышенной детализацией: ‐‐color-words. В этом режиме добавленные и удаленные строки отделяются пробелами, а затем выполняется их сравнение.  
   * **git diff-highlight** - при клонировании источника Git появляется подкаталог с именем contrib. Он содержит набор связанных с Git инструментов и различные данные, которые пока еще не были включены в ядро Git. В их число входит скрипт Perl под названием diff-highlight. Diff-highlight попарно сопоставляет совпадающие строки выходных данных сравнения и подсвечивает измененные фрагменты внутри слов.  

1. ## Удаление отслеживаемых файлов из текущего рабочего дерева
   Удалять файлы из текущего рабочего дерева можно с помощью параметра **rm**. При этом файлы удаляются и из индекса.  
*git rm dirname/somefile.js*  
   >Можно также использовать маски файлов (например *.js) для удаления всех файлов, соответствующих критерию.  
*git rm dirname/*.html*  

   * **git rm text.txt** - удалить отслеживаемый неизменённый файл и проиндексировать это изменение  
   * **git rm -f text.txt** - удалить отслеживаемый изменённый файл и проиндексировать это изменение  
   * **git rm -r log/** - удалить всё содержимое отслеживаемой директории log/ и проиндексировать это изменение  
   * **git rm ind*** - удалить все отслеживаемые файлы с именем, начинающимся на «ind» в текущей директории и проиндексировать это изменение  
   * **git rm --cached readme.txt** - удалить из отслеживаемых индексированный файл (ФАЙЛ ОСТАНЕТСЯ НА МЕСТЕ) (часто используется для нечаянно добавленных в отслеживаемые файлов)
1. ## Переименование файлов
   Переименовать файл или папку можно параметром **mv**. Для него указывается источник *source* и назначение *destination*. Источник - реально существующий файл или папка, а назначение - существующая папка.  
   *git mv dir1/somefile.js dir2*  
   При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.  
   * **git mv text.txt test_new.txt** - переименовать файл *«text.txt»* в *«test_new.txt»* и проиндексировать это изменение  
   * **git mv readme_new.md folder/** - переместить файл *readme_new.md* в директорию *folder/* (должна существовать) и проиндексировать это изменение  
1. ## Отмена подготовленных и неподготовленных изменений
   Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром **checkout**. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр **git checkout** изменит указатель *HEAD*, чтобы задать указанную ветку как текущую.  
   *git checkout somefile.js*  
   Восстановить подготовленный файл рабочего дерева можно параметром **reset**. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.  
   *git reset HEAD somefile.js*  
   Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.
   *git reset HEAD*
1. ## Изменение последнего коммита
   Внести изменения в последний коммит можно параметром **commit** с флагом **--amend--**. Можно воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.  
   *git commit --amend -m "Updated message for the previous commit"*  
   >Также можно вносить изменения в файлы, отправленные ранее. Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами **–amend** и **--no-edit**.  

   ```git add dir1  
   git commit  
   Here you forgot to add dir2 to commit, you can execute the following command to amend the other files and folders.  
   git add dir2  
   git commit --amend --no-edit
   ```  

   Флаг **--no-edit** позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.
   ## Внимание! Не изменяйте публичные коммиты.
   С помощью **amend** прекрасно исправляются локальные коммиты, а исправления можно передать в общий репозиторий. Однако изменять коммиты, уже доступные другим пользователям, не следует. __*Помните, что изменённые коммиты являются совершенно новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия будут такими же, как при отмене изменений публичного снимка.*__
1. ## Откат последнего коммита
   Откатить последний коммит можно с помощью параметра **revert**. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.
   * **git revert HEAD**  
   * **git revert HEAD --no-edit** - создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения
   * **git revert b9533bb --no-edit** - то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)  
   **Разница между revert и reset**  
      Команда **git revert** отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда **git reset**.
      У команды **revert** есть два крупных преимущества по сравнению с **reset**.  
      *Во-первых*, она не меняет историю проекта и производит операцию, безопасную для коммитов.  
      *Во-вторых*, её объектом выступает конкретный коммит, созданный в любой момент истории, а **git reset** всегда берёт за точку отсчёта текущий коммит.  
      >К примеру, если нужно отменить старый коммит с помощью **git reset**, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда **git revert** - гораздо более удобный и безопасный способ отмены изменений.
   
   * **git reset** - убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), антипод git add  
   * **git reset readme.txt** - убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся)
   * **git checkout text.txt** - **ОПАСНО:** отменить изменения в файле, вернуть состояние файла, имеющееся в индексе  
   * **git reset --hard** - **ОПАСНО:** отменить изменения; вернуть то, что в коммите, на который указывает HEAD (незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)
   * **git clean -df** - удалить неотслеживаемые файлы и директории  

   Все команды, приведённые ниже можно выполнять **ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.**
   # `ВНИМАНИЕ!` Опасные команды, `можно потерять незакоммиченные изменения`
   * **git commit --amend -m "Название"** - «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)   
   * **git reset --hard @~** - передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита  
   * **git reset --hard 75e2d51** - передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита  
   * **git reset --soft @~** - передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения  
   * **git reset --soft @~2** - то же, но передвинуть HEAD (и ветку) на 2 коммита назад  
   * **git reset @~** - передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем **git reset --soft @~**, если индекс нужно задать заново)
   ### Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории
   * **git reset --keep @~** - передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)
1. ## Откат заданного коммита
   Откатить проект до заданного коммита можно с помощью параметра **revert** и идентификатора коммита. Создастся новый коммит — копия коммита с предоставленным идентификатором — и добавится к истории текущей ветки.  
   *git revert 1af17e*
1. ## Создание новой ветки и переход в неё
   Создать новую ветку можно с помощью параметра **branch**, указав имя ветки.  
   **git branch new_branch_name**  
   Но Git не переключится на неё автоматически. Для автоматического перехода нужно добавить флаг **–b** и параметр **checkout**.  
   **git checkout -b new_branch_name**  
   * **git checkout b9533bb** - переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита)  
   * **git checkout master** - переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита)  
   * **git checkout -b new-branch 5589877** - создать ветку new-branch, начинающуюся с коммита c хешем 5589877 (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита, создать указатель на этот коммит (ветку) с указанным именем)  
   * **git checkout 5589877 index.html** - восстановить в рабочей директории указанный файл на момент указанного коммита (и добавить это изменение в индекс) (git reset index.html для удаления из индекса, но сохранения изменений в файле)
1. ## Просмотр списка веток
   Можно просматривать полный список веток, используя параметр **branch**. Команда отобразит все ветки, отметит текущую звёздочкой (*) и выделит её цветом.  
   **git branch**  
   Также можно вывести список удалённых веток с помощью флага **-a**.  
   **git branch -a**
1. ## Удаление ветки
   Удалить ветку можно параметром **branch** с добавлением флага **–d** и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.  
   **git branch -d existing_branch_name**  
   Для принудительного удаления ветки используется флаг **–D** с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.  
   **git branch -D existing_branch_name**  
   Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:  
   **git push origin --delete existing_branch_name**  
   * **git branch** - показать список веток  
   * **git branch -v** - показать список веток и последний коммит в каждой  
   * **git branch new_branch** - создать новую ветку с указанным именем на текущем коммите  
   * **git branch new_branch 5589877** - создать новую ветку с указанным именем на указанном коммите  
   * **git branch -f master 5589877** - переместить ветку master на указанный коммит  
   * **git branch -f master master~2** - переместить ветку master на 2 коммита назад  
   * **git checkout new_branch** - перейти в указанную ветку  
   * **git checkout -b new_branch** - создать новую ветку с указанным именем и перейти в неё  
   * **git checkout -B master 5589877** - переместить ветку с указанным именем на указанный коммит и перейти в неё  
   * **git merge hotfix** - влить в ветку, в которой находимся, данные из ветки hotfix  
   * **git merge hotfix -m "Горячая правка"** - влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)  
   * **git merge hotfix --log** - влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов  
   * **git merge hotfix --no-ff** - влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния  
   * **git branch -d hotfix** - удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)  
   * **git branch --merged** - показать ветки, уже слитые с активной  
   * **git branch --no-merged** - показать ветки, не слитые с активной  
   * **git branch -a** - показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)  
   * **git branch -m old_branch_name new_branch_name** - переименовать локально ветку old_branch_name в new_branch_name  
   * **git branch -m new_branch_name** - переименовать локально ТЕКУЩУЮ ветку в new_branch_name  
   * **git push origin :old_branch_name new_branch_name** - применить переименование в удаленном репозитории  
   * **git branch --unset-upstream** - завершить процесс переименования  
1. ## Слияние двух веток
   Объединить две ветки можно параметром **merge** с указанием имени ветки. Команда объединит указанную ветку с основной.  
   **git merge existing_branch_name**  
   Если надо выполнить коммит слияния, выполните команду **git merge** с флагом **--no-ff**.  
   **git merge --no-ff existing_branch_name** - 
   Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.
1. ## Отображение журнала фиксации в виде графика для текущей или всех веток
   Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра **log** и флагов **--graph --oneline --decorate**. Опция **–graph** выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами **–oneline** и **--decorate**, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.  
   **git log --graph --oneline --decorate**  
   Для просмотра истории коммитов по всем веткам используется флаг **--all**.
   **git log --all --graph --oneline --decorate**
1. ## Прекращение слияния при конфликте
   Прервать слияние в случае конфликта можно параметром merge с флагом **--abort**. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.  
   **git merge --abort**  
   Также при конфликте слияния можно использовать параметр **reset**, чтобы восстановить конфликтующие файлы до стабильного состояния.  
   **git reset**
   >Конфликт слияния
   Предполагается ситуация: есть ветка **master** и есть ветка **feature**. В обеих ветках есть коммиты, сделанные после расхождения веток. В ветку master пытаемся влить ветку feature **(git merge feature)**, получаем конфликт, т.к. в обеих ветках есть изменения одной и той же строки в файле *index.html*.
   При возникновении конфликта, репозиторий находится в состоянии прерванного слияния. Нужно оставить в конфликтующих местах файлов только нужный код, проиндексировать изменения и закоммитить.  

   * **git merge feature** - влить в активную ветку изменения из ветки *feature*
   * **git merge-base master feature** - показать хеш последнего общего коммита для двух указанных веток  
   * **git checkout --ours index.html** - оставить в конфликтном файле (index.html) состояние ветки, В КОТОРУЮ мы вливаем (в примере — из ветки *master*)  
   * **git checkout --theirs index.html** - оставить в конфликтном файле (index.html) состояние ветки, ИЗ КОТОРОЙ мы вливаем (в примере — из ветки feature)  
   * **git checkout --merge index.html** - показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток (для ручного редактирования)  
   * **git checkout --conflict=diff3  --merge index.html** - показать в конфликтном файле (index.html) сравнение содержимого сливаемых веток плюс то, что было в месте конфликта в коммите, на котором разошлись сливаемые ветки  
   * **git reset --hard** - прекратить это прерванное слияние, вернуть рабочую директорию и индекс как было в момент коммита, на который указывает HEAD  
   * **git reset --merge** - прекратить это прерванное слияние, но оставить изменения, не закоммиченные до слияния (для случая, когда слияние делается не на чистом статусе)  
   * **git reset --abort** - то же, что и строкой выше
1. ## Добавление удалённого репозитория
   Добавить удалённый репозиторий можно параметром **remote add**, указав **shortname** и **url** требуемого репозитория.  
   **git remote add awesomeapp https://github.com/someurl..**  
   >Есть два распространённых способа привязать удалённый репозиторий к локальному: по HTTPS и по SSH. Если SSH у вас не настроен (или вы не знаете что это), привязывайте удалённый репозиторий по HTTPS (адрес привязываемого репозитория должен начинаться с https://).  

   * **git remote -v** - показать список удалённых репозиториев, связанных с локальным  
   * **git branch -r** - показать удаленные ветки  
   * **git branch -a** - показать все ветки(локальные и удаленные)         
   * **git remote remove origin** - убрать привязку удалённого репозитория с сокр. именем *origin*  
   * **git remote add origin https://github.com:nicothin/test.git** - добавить удалённый репозиторий (с сокр. именем origin) с указанным URL  
   * **git remote rm origin** - удалить привязку удалённого репозитория  
   * **git remote show origin** - получить данные об удалённом репозитории с сокращенным именем origin  
   * **git fetch origin** - скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками  
   * **git fetch origin master** - то же, но скачивается только указанная ветка  
   * **git checkout --track origin/github_branch** - создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё  
   * **git push origin master** - отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master  
   * **git pull origin** - влить изменения с удалённого репозитория (все ветки)  
   * **git pull origin master** - влить изменения с удалённого репозитория (только указанная ветка)  
1. ## Просмотр удалённых URL-адресов
   Просматривать удалённые URL-адреса можно параметром **remote** с флагом **-v**. Этот параметр отображает удалённые подключения к другим репозиториям.  
   **git remote -v**  
   Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле _**.git/config**_ репозитория.
1. ## Получение дополнительных сведений об удалённом репозитории
   Получить подробные сведения об удалённом репозитории можно с помощью параметра **remote show** с указанием имени  репозитория — например, -**origin**-.  
   **git remote show origin**  
   Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.
1. ## Отправка изменений в удалённый репозиторий
   Отправлять изменения в удалённый репозиторий можно параметром **push** с указанием имени репозитория и ветки.   
   **git push origin main**  
   Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.
1. ## Получение изменений из удалённого репозитория
   Для загрузки изменений из удалённого  репозитория используется параметр **pull**. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.  
   **git pull**  
   Также можно просмотреть подробные сведения о загруженных файлах с помощью флага **--verbose**.  
   **git pull --verbose**
1. ## Слияние удалённого репозитория с локальным
   Слияние удалённого репозитория с локальным выполняется параметром **merge** с указанием имени удалённого репозитория.  
   **git merge origin**
1. ## Отправка новой ветки в удалённый репозиторий
   Передать новую ветку в удалённый репозиторий можно параметром **push** с флагом **-u**, указав имя репозитория и имя ветки.  
   **git push -u origin new_branch**
1. ## Удаление удалённой ветки
   Чтобы избавиться от удалённой ветки, используйте параметр **push** с флагом **--delete**, указав имя удалённого репозитория и имя ветки.  
   **git push --delete origin existing_branch**
1. ## Использование перебазирования
   Для доступа к этой функции используйте параметр **rebase** с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.  
   **git rebase branch_name**  
   Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.
1. ## «Перенос» ветки
   Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).  
   >Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

   **git rebase master** - перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от _**master**_ на нынешней вершине master (часто вызывает конфликты)
   **git rebase --onto master feature** - перенести коммиты активной ветки на _**master**_, начиная с того места, в котором активная ветка отделилась от ветки _**feature**_  
   **git rebase --abort** - прервать конфликтный _**rebase**_, вернуть рабочую директорию и индекс к состоянию до начала _**rebase**_  
   **git rebase --continue** - продолжить конфликтный _**rebase**_ (сработает только после разрешения конфликта и индексации такого разрешения)
1. ## Как отменить **rebase**
   **git reflog feature -2** - смотрим лог перемещений ветки, которой делали _**rebase**_ (в этом примере — _feature_), видим последний коммит **ПЕРЕД _rebase_**, на него и нужно перенести указатель ветки  
   **git reset --hard feature@{1}** - переместить указатель ветки _**feature**_ на один коммит назад, обновить рабочую директорию и индекс  
1. ## Указание неотслеживаемых файлов
   Файлы и директории, которые не нужно включать в репозиторий, указываются в файле **.gitignore**. Обычно это устанавливаемые зависимости (*node_modules/, bower_components/*), готовая сборка *build/* или *dist/* и подобные, создаваемые при установке или запуске. Каждый файл или директория указываются с новой строки, возможно использование шаблонов.
1. ## Копирование коммита (перенос коммитов)
   **git cherry-pick 5589877** - скопировать на активную ветку изменения из указанного коммита, закоммитить эти изменения  
   **git cherry-pick master~2..master** - скопировать на активную ветку изменения из _master_ (2 последних коммита)  
   **git cherry-pick -n 5589877** - скопировать на активную ветку изменения из указанного коммита, но НЕ КОММИТИТЬ (подразумевается, что мы сами потом закоммитим)  
   **git cherry-pick master..feature** -скопировать на активную ветку изменения из всех коммитов ветки _feature_ с момента её расхождения с _master_ (похоже на слияние веток, но это копирование изменений, а не слияние), закоммитить эти изменения; это может вызвать конфликт   
   **git cherry-pick --abort** - прервать конфликтный перенос коммитов  
   **git cherry-pick --continue** - продолжить конфликтный перенос коммитов (сработает только после решения конфликта)
1. ## Тэги
   **git tag v1.0.0** - создать тег с указанным именем на коммите, на который указывает *HEAD*  
   **git tag -a -m 'В продакшен!' v1.0.1 master** - создать тег с описанием на том коммите, на который смотрит ветка _master_  
   **git tag -d v1.0.0** - удалить тег с указанным именем(ами)  
   **git tag -n** - показать все теги, и по 1 строке сообщения коммитов, на которые они указывают  
   **git tag -n -l 'v1.*'** - показать все теги, которые начинаются с 'v1.*'  
1. ## Временное сохранение изменений без коммита
   **git stash** позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы вы могли применить их позже. Откладывание изменений полезно, если вам необходимо переключить контекст и вы пока не готовы к созданию коммита.  
   **git stash** - временно сохранить незакоммиченные изменения и убрать их из рабочей директории  
   **git stash pop** - вернуть сохраненные командой git stash изменения в рабочую директорию  
   **git stash -u** -  (или --include-untracked) позволяет отложить неотслеживаемые файлы